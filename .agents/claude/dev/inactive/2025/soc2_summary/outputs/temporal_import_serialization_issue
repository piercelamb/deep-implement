Why we needed to pass the activity as a parameter:

  Temporal's workflow sandbox isolates each workflow's namespace. When an activity returns a dataclass with type-annotated fields (like GetVellumDocumentActivityOutput with indexing_state: VellumIndexingState), Temporal needs to resolve those types during deserialization.

  If the activity module isn't imported in the workflow's workflow.unsafe.imports_passed_through() block, the sandbox can't find VellumIndexingState and throws a NameError.

  By having the workflow import get_vellum_document_activity and pass it to the utility:
  1. The import is genuinely used (not flagged by ruff)
  2. The activity module becomes available in the workflow's sandbox
  3. Type resolution works during deserialization
  4. The dependency is explicit - callers know what activity the utility needs

  Files changed:
  - ai_services/temporal_workers/workflows/utils.py - check_document_indexed now takes activity parameter
  - ai_services/temporal_workers/workflows/vrm/summary_soc2_workflow_v1.py - imports and passes the activity
  - tests/temporal_workers/test_summary_soc2_workflow_v1.py - added mocks and tests for document check failures

  Sources from research:
  - https://docs.temporal.io/develop/python/python-sdk-sandbox
  - https://github.com/temporalio/sdk-python/issues/399
  - https://community.temporal.io/t/structuring-sandbox-friendly-activity-imports-when-using-the-python-sdk/6546

---

You're right to question it. I checked Temporal's actual types:

  # Temporal's execute_activity signature
  activity: 'Any'  # That's what Temporal uses!

  Temporal uses Any because execute_activity has multiple @overload signatures for static type checking, but the runtime signature is Any.

  We could be more precise:
  Callable[[GetVellumDocumentActivityInput], GetVellumDocumentActivityOutput]

  But that would require importing GetVellumDocumentActivityOutput in utils.py, which brings us back to the type resolution problem we're trying to avoid.

  So Callable[..., Any] is actually appropriate here because:
  1. Temporal itself uses Any for the activity parameter
  2. Importing output types defeats the purpose - we'd need GetVellumDocumentActivityOutput which references VellumIndexingState
  3. The caller is responsible for passing the correct activity

  The alternative would be to create a Protocol that describes the activity's signature, but that would also require the output type.

  Bottom line: Callable[..., Any] matches Temporal's own approach and avoids the circular dependency.

  Sources:
  - https://python.temporal.io/temporalio.workflow.html
  - https://docs.temporal.io/develop/python/core-application